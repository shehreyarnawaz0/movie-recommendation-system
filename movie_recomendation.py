# -*- coding: utf-8 -*-
"""movie recomendation

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EcD4dmRyB5FSkeIlWnC8NdNSPFAWZwvO

# Task
Build a movie recommendation system using content-based filtering with the dataset located at "/content/drive/MyDrive/movies.csv". The system should recommend movies based on genre similarity and display at least 3 recommendations for a given movie. Use pandas and sklearn, and explain the approach in comments.

## Data loading and preparation

### Subtask:
Load the `movies.csv` dataset and prepare the data, focusing on movie titles and genres.

**Reasoning**:
Load the movies dataset, display the first few rows, check for missing values in 'title' and 'genres', and ensure their data types are strings.
"""

import pandas as pd

# Load the dataset
df_movies = pd.read_csv("/content/drive/MyDrive/movies.csv")

# Display the first few rows
display(df_movies.head())

# Check for missing values in 'title' and 'genres'
print("\nMissing values before handling:")
print(df_movies[['title', 'genres']].isnull().sum())

# Handle missing values (if any) - for simplicity, we'll drop rows with missing values in relevant columns
df_movies.dropna(subset=['title', 'genres'], inplace=True)

print("\nMissing values after handling:")
print(df_movies[['title', 'genres']].isnull().sum())


# Ensure data types are strings
df_movies['title'] = df_movies['title'].astype(str)
df_movies['genres'] = df_movies['genres'].astype(str)

print("\nData types after ensuring string format:")
print(df_movies[['title', 'genres']].dtypes)

"""## Feature extraction

### Subtask:
Convert the movie genres into a format that can be used to calculate similarity between movies (e.g., using TF-IDF).

**Reasoning**:
Import the necessary vectorizer and transform the movie genres into a TF-IDF matrix for similarity calculations.
"""

from sklearn.feature_extraction.text import TfidfVectorizer

# Create a TF-IDF vectorizer
tfidf_vectorizer = TfidfVectorizer(stop_words='english')

# Fit and transform the genre data
tfidf_matrix = tfidf_vectorizer.fit_transform(df_movies['genres'])

# Display the shape of the TF-IDF matrix
print("Shape of TF-IDF matrix:", tfidf_matrix.shape)

"""## Calculate similarity

### Subtask:
Compute the similarity between movies based on their genre features, likely using cosine similarity.

**Reasoning**:
Calculate the cosine similarity matrix based on the TF-IDF matrix.
"""

from sklearn.metrics.pairwise import cosine_similarity

# Calculate the cosine similarity matrix
cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

# Display the shape of the similarity matrix
print("Shape of cosine similarity matrix:", cosine_sim.shape)

"""## Generate recommendations

### Subtask:
Based on the similarity scores, generate recommendations for a movie similar to a given movie.

**Reasoning**:
Define a function to get movie recommendations based on cosine similarity scores.
"""

def get_recommendations(title, cosine_sim=cosine_sim):
    """
    Get movie recommendations based on genre similarity.

    Args:
        title (str): The title of the movie.
        cosine_sim (numpy.ndarray): The cosine similarity matrix.

    Returns:
        list: A list of recommended movie titles.
    """
    # Get the index of the movie that matches the title
    try:
        idx = df_movies[df_movies['title'] == title].index[0]
    except IndexError:
        print(f"Movie with title '{title}' not found.")
        return []

    # Get the pairwise similarity scores for that movie
    sim_scores = list(enumerate(cosine_sim[idx]))

    # Sort the movies based on the similarity scores
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

    # Get the scores of the 10 most similar movies (excluding the movie itself)
    sim_scores = sim_scores[1:11]

    # Get the movie indices
    movie_indices = [i[0] for i in sim_scores]

    # Return the top 10 most similar movie titles
    return df_movies['title'].iloc[movie_indices].tolist()

# Example usage: Get recommendations for 'Toy Story (1995)'
recommendations = get_recommendations('Toy Story (1995)')
print(f"Recommendations for 'Toy Story (1995)':")
for movie_title in recommendations:
    print(movie_title)

"""## Filter Movies by Genre

### Subtask:
Create a function to filter and display movie titles based on user-provided genres.

**Reasoning**:
Define a function that takes a genre (or a list of genres) as input and returns a list of movie titles that include those genres.
"""

def get_movies_by_genre(genres):
    """
    Get movie titles that belong to the specified genre(s).

    Args:
        genres (str or list): A single genre string or a list of genre strings.

    Returns:
        list: A list of movie titles matching the specified genre(s).
    """
    if isinstance(genres, str):
        genres = [genres]

    # Filter movies where the 'genres' string contains all specified genres
    # This assumes genres in the DataFrame are pipe-separated (e.g., "Action|Adventure")
    filtered_movies = df_movies[
        df_movies['genres'].apply(lambda x: all(g in x for g in genres))
    ]

    return filtered_movies['title'].tolist()

# Example usage: Get movies in the 'Animation' and 'Children' genres
animation_children_movies = get_movies_by_genre(['Animation', 'Children'])
print("Movies in 'Animation' and 'Children' genres:")
for title in animation_children_movies[:10]: # Displaying first 10 for brevity
    print(title)

"""## Interactive Genre Filtering

### Subtask:
Allow the user to input genres and display movie titles matching those genres.

**Reasoning**:
Prompt the user for genre input, process the input to handle multiple genres, and call the `get_movies_by_genre` function to display the results.
"""

# Get genre input from the user
input_genres_str = input("Enter one or more genres (separated by comma or pipe, e.g., Action|Comedy or Animation,Children): ")

# Process the input string into a list of genres
# Handle both comma and pipe separators
if '|' in input_genres_str:
    input_genres = [genre.strip() for genre in input_genres_str.split('|')]
elif ',' in input_genres_str:
    input_genres = [genre.strip() for genre in input_genres_str.split(',')]
else:
    # If no separator, assume it's a single genre
    input_genres = [input_genres_str.strip()]


# Get movies matching the user-provided genres
genre_filtered_movies = get_movies_by_genre(input_genres)

# Print the results
print(f"\nMovies in genre(s) '{input_genres_str}':")
if genre_filtered_movies:
    # Displaying first 20 for brevity
    for title in genre_filtered_movies[:20]:
        print(title)
    if len(genre_filtered_movies) > 20:
        print(f"... and {len(genre_filtered_movies) - 20} more movies.")
else:
    print("No movies found matching the specified genre(s). Please check the genre spelling and try again (e.g., Animation, Children, Drama, Comedy, Action, Romance, Thriller, Adventure, Sci-Fi, Fantasy, Crime, Mystery, Horror, Film-Noir, Musical, War, Western, IMAX, Documentary).")